/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable unused-imports/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */
import type { Head, Head2, ParserError, TailBy } from './utils.ts'
import type { IsToken, ASTs, ASTTypes, SelectToken } from './AST.ts'
import type { Tokenize } from './tokenizer.ts'
import type { Engine } from './index.ts'
import type { Debug } from '@kubb/core'

export type ParseTypes = {
  Identifier: 'Identifier'
}

export type Parsers = { type?: keyof ParseTypes; [x: string]: any }

type ParseIdentifier<Tokens extends ASTs[], Res extends Parsers, LookBack extends ASTs, Cursor extends ASTs, LookAhead extends ASTs> = Res extends {
  type: ParseTypes['Identifier']
}
  ? LookBack extends { type: ASTTypes['LINEBREAK'] }
    ? // Tag:
      Debug<
        {
          type: 'IdentifierRoot'
          debug: {
            CurrCursor: Cursor
            PrevToken: LookBack
            CurrTokens: Tokens
          }
          value: Res
          children: ParserInternal<TailBy<Tokens, 1>>
        },
        Engine['debug']['parser']
      >
    : // type: object
      [
        Debug<
          {
            type: 'Identifier'
            debug: {
              CurrCursor: Cursor
              PrevToken: LookBack
              CurrTokens: Tokens
              test: [SelectToken<Tokens[0], 'COLLON'>]
            }
            value: Res['value']
            children: LookAhead extends { type: ASTTypes['IDENT'] }
              ? LookAhead['name']
              : // check to see if value property exists(or we have a ts error)
              ParserInternal<TailBy<Tokens, 1>> extends { value: string }
              ? ParserInternal<TailBy<Tokens, 1>>['value']
              : never
          },
          Engine['debug']['parser']
        >,
      ]
  : never

/**
 * Tokens: ASTs that are generated by TokenizeInternal
 * Acc: NOT NEEDED
 * Cursor: Current AST Token
 * Res: object created out of the parsers(JSON format)
 */
type ParserInternal<
  Tokens extends ASTs[],
  Res extends Parsers = {},
  LookBack extends ASTs = never,
  Cursor extends ASTs = Head<Tokens>,
  LookAhead extends ASTs = Head2<Tokens>,
> = IsToken<Cursor, 'LINEBREAK' | 'COLLON'> extends true // skip linebreak and collon
  ? ParserInternal<TailBy<Tokens, 1>, Res, Head<Tokens>>
  : IsToken<Cursor, 'IDENT'> extends true
  ? ParserInternal<TailBy<Tokens, 1>, Res & { type: 'Identifier'; value: Cursor['name'] }, Head<Tokens>>
  : [LookAhead] extends [never]
  ? ParserError<`Unexpected end of input, expected IDENT`>
  : LookAhead extends {
      type: ASTTypes['IDENT']
    }
  ? ParseIdentifier<Tokens, Res, LookBack, Cursor, LookAhead>
  : never

//ParserError<`Expected token of type IDENT, got ${LookAhead['type']}`>
export type Parser<Tokens extends ASTs[]> = ParserInternal<Tokens>

type Schema1 = `
Pet:
  description: test
  required: true
`

type Schema2 = `
Pet:
  type: object
  description: test
  required: true
Tag:
  type: object
  properties:
    id:
      type: integer
      format: int64
    name:
      type: string
`
type Token1 = Tokenize<Schema1>
//    ^?
// [Identifier<"Pet">, Collon, LineBreak<1>, Indent<2>, Identifier<"description">, Collon, Indent<1>, Identifier<"test">, LineBreak<1>, Indent<2>, Identifier<"required">, Collon, Indent<1>, Identifier<"true">]
type Demo1 = Parser<Token1>
//    ^?

type Demo2 = Parser<Tokenize<Schema2>>
//    ^?
