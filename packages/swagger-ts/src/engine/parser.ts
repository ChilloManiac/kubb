/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable unused-imports/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */
import type { HasNoErrors, Head, Head2, ParserError, TailBy } from './utils.ts'
import type { IsToken, ASTs, ASTTypes, SelectToken, Identifier, Collon, Indent, LineBreak } from './AST.ts'
import type { Tokenize } from './tokenizer.ts'
import type { Engine } from './index.ts'
import type { Debug } from '@kubb/core'

export type ParseTypes = {
  Identifier: 'Identifier'
}

export type Parsers = { type?: keyof ParseTypes; [x: string]: any }
/**
 * type: object
 */
type ParseIdentifier<Tokens extends ASTs[], Res extends Parsers, LookBack extends ASTs, Cursor extends ASTs, LookAhead extends ASTs> = Debug<
  {
    type: 'Identifier'
    debug: {
      // CurrCursor: Cursor
      // CurrTokens: Tokens
      // PrevToken: LookBack
      // NextToken: LookAhead
      // [LineBreak<1> and Indent<x>]
      // NextIndentLevel: HasErrors<SelectToken<Tokens[1], 'LINEBREAK'> | SelectToken<Tokens[2], 'INDENT'>> extends true
      //   ? ParserError<'[LineBreak<1>, Indent<x>] order not found'>
      //   : Extract<SelectToken<Tokens[2], 'INDENT'>, { level: number }>['level']
      // IndentNext: TailBy<Tokens, 3>
    }
    value: Res['value']
    children: LookAhead extends { type: ASTTypes['IDENT'] } ? LookAhead['name'] : Cursor['name']
  },
  Engine['debug']['parser']
>

/**
 *  [Identifier<'type'>, Collon, Indent<1>, Identifier<'object'>, LineBreak<1>, Indent<2>, Identifier<'description'>]
 */
type ParseIdentifiers<Tokens extends ASTs[], Res extends Parsers[] = [], Cursor = Head<Tokens>> = Cursor extends []
  ? Res extends []
    ? Res
    : Res
  : HasNoErrors<SelectToken<Tokens[4], 'LINEBREAK'> | SelectToken<Tokens[5], 'INDENT'>> extends true
  ? ParseIdentifiers<TailBy<Tokens, 6>, [...Res, ParserInternal<TailBy<Tokens, 6>>], Head<TailBy<Tokens, 6>>>
  : Res

type ParseRootIdentifier<Tokens extends ASTs[], Res extends Parsers, LookBack extends ASTs, Cursor extends ASTs, LookAhead extends ASTs> = LookBack extends {
  type: ASTTypes['LINEBREAK']
}
  ? // Tag:\n
    Debug<
      {
        type: 'RootIdentifier'
        debug: {
          // CurrCursor: Cursor
          // CurrTokens: Tokens
          // PrevToken: LookBack
          // NextToken: LookAhead
          // [Collon, Indent<x>, Identifier<"object">, LineBreak<1> and Indent<x>]
          NextIndentLevel: HasNoErrors<SelectToken<Tokens[4], 'LINEBREAK'> | SelectToken<Tokens[5], 'INDENT'>> extends true
            ? Extract<SelectToken<Tokens[2], 'INDENT'>, { level: number }>['level']
            : ParserError<'[LineBreak<1>, Indent<x>] order not found'>
        }
        value: Res
        children: [
          // IsToken<Head<Tokens>, 'IDENT'> extends true
          //   ? // ParserInternal<Tokens> extends { type: 'Identifier'; value: string; children: ASTs }
          //     {
          //       value: Extract<Head<Tokens>[0], ASTs>['value']
          //       children: Extract<Head<Tokens>[0], ASTs>['children']['name']
          //     }
          //   : // loop back to type: 'Identifier'
          //     ParserInternal<Tokens>,
          ParserInternal<Tokens>,
          ...ParseIdentifiers<Tokens>,
          // Equal<LookBack extends ASTs ? LookBack['level'] : never, Indent>,
        ]
      },
      Engine['debug']['parser']
    >
  : // type: object

    ParseIdentifier<Tokens, Res, LookBack, Cursor, LookAhead>

/*
  TODO check if indent is lower than the previous one and return Res instead, UPDATE: move to higher level(ParseRootIdentifier)
     Equal<Tokens[5]['level'], PrevIndent> extends true
    */

/**
 * Tokens: ASTs that are generated by TokenizeInternal
 * Cursor: Current AST Token
 * Res: object created out of the parsers(JSON format)
 */
type ParserInternal<
  Tokens extends ASTs[],
  Res extends Parsers = {},
  LookBack extends ASTs = never,
  Cursor extends ASTs = Head<Tokens>,
  LookAhead extends ASTs = Head2<Tokens>,
> = IsToken<Cursor, 'LINEBREAK' | 'COLLON'> extends true // skip linebreak and collon
  ? ParserInternal<TailBy<Tokens, 1>, Res, Head<Tokens>>
  : IsToken<Cursor, 'IDENT'> extends true
  ? // keep data to reuse later on when checking on Res, we need the correct name here
    // ParserInternal<TailBy<Tokens, 1>, Res & { type: 'Identifier'; value: Cursor['name']; indent: Cursor['indent'] }, Head<TailBy<Tokens, 1>>>
    ParserInternal<TailBy<Tokens, 1>, Res & { type: 'Identifier'; value: Cursor['name'] }, Head<TailBy<Tokens, 1>>>
  : LookAhead extends {
      type: ASTTypes['IDENT']
    }
  ? // TODO split tokens per LINEBREAK/INDENT to create a children array with only those needed and push the rest back to the main parser
    // adding more data to Res based on previous check(see type Identifier)
    Res extends {
      type: ParseTypes['Identifier']
    }
    ? ParseRootIdentifier<TailBy<Tokens, 1>, Res, LookBack, Head<TailBy<Tokens, 1>>, Head2<TailBy<Tokens, 1>>>
    : never
  : Res

//ParserError<`Expected token of type IDENT, got ${LookAhead['type']}`>
export type Parser<Tokens extends ASTs[]> = ParserInternal<Tokens>

type Schema1 = `
Pet:
  description: test
  required: true
`

type Schema2 = `
Tag:
  type: object
  properties:
    id:
      type: integer
      format: int64
    name:
      type: string
`
type Token1 = Tokenize<Schema1>
//    ^?
// [Identifier<"Pet">, Collon, LineBreak<1>, Indent<2>, Identifier<"description">, Collon, Indent<1>, Identifier<"test">, LineBreak<1>, Indent<2>, Identifier<"required">, Collon, Indent<1>, Identifier<"true">]
type Token2 = Tokenize<Schema2>
//    ^?
type Demo1 = Parser<Token1>
//    ^?

type Demo2 = Parser<Tokenize<Schema2>>
//    ^?

const parseIdentifiersDemoSchema = `
properties:
  id:
    type: integer
  name:
    type: string
`

type Token3 = Tokenize<typeof parseIdentifiersDemoSchema>
//    ^?
type ParseIdentifiersDemo = Parser<
  [
    Identifier<'properties', 0>,
    Collon,
    LineBreak<1>,
    Indent<2>,
    Identifier<'id', 2>,
    Collon,
    LineBreak<1>,
    Indent<4>,
    Identifier<'type', 4>,
    Collon,
    Indent<1>,
    Identifier<'integer', 1>,
    LineBreak<1>,
    Indent<2>,
    Identifier<'name', 2>,
    Collon,
    LineBreak<1>,
    Indent<4>,
    Identifier<'type', 4>,
    Collon,
    Indent<1>,
    Identifier<'string', 1>,
  ]
>
//    ^?
